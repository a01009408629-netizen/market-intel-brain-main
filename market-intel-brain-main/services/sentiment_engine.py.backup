"""
MAIFA v3 Sentiment Engine Service - Cognitive Layer
Advanced sentiment analysis with multiple models and confidence scoring
"""

import asyncio
import logging
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
import re
import json

from models.schemas import SentimentResult
from models.datatypes import SentimentScore, ConfidenceScore

class SentimentEngine:
    """
    MAIFA v3 Sentiment Engine - Advanced sentiment analysis
    
    Provides multiple sentiment analysis approaches including:
    - TextBlob-based sentiment analysis
    - Keyword-based sentiment scoring
    - Financial sentiment patterns
    - Confidence scoring
    """
    
    def __init__(self):
        self.logger = logging.getLogger("SentimentEngine")
        self._positive_keywords = self._load_positive_keywords()
        self._negative_keywords = self._load_negative_keywords()
        self._financial_patterns = self._load_financial_patterns()
        self._sentiment_cache = {}
        
    def _load_positive_keywords(self) -> List[str]:
        """Load positive sentiment keywords"""
        return [
            "bullish", "positive", "growth", "increase", "rise", "surge", "rally",
            "strong", "excellent", "good", "great", "amazing", "outstanding",
            "profit", "profitable", "gain", "win", "success", "successful",
            "buy", "buying", "opportunity", "undervalued", "cheap", "breakout",
            "momentum", "uptrend", "higher", "above", "beat", "exceeds"
        ]
    
    def _load_negative_keywords(self) -> List[str]:
        """Load negative sentiment keywords"""
        return [
            "bearish", "negative", "decline", "decrease", "drop", "fall", "crash",
            "weak", "poor", "bad", "terrible", "awful", "disappointing",
            "loss", "losing", "lose", "fail", "failure", "unsuccessful",
            "sell", "selling", "risk", "risky", "dangerous", "overvalued",
            "expensive", "breakdown", "downtrend", "lower", "below", "miss",
            "concern", "worry", "fear", "panic", "crisis", "recession"
        ]
    
    def _load_financial_patterns(self) -> List[Dict[str, Any]]:
        """Load financial sentiment patterns"""
        return [
            {
                "pattern": r"(price|stock|shares?) (is|are) (rising|falling|dropping|gaining|losing)",
                "sentiment": "contextual",
                "weight": 0.8
            },
            {
                "pattern": r"(market|index) (is|are) (up|down|higher|lower)",
                "sentiment": "contextual", 
                "weight": 0.7
            },
            {
                "pattern": r"(earnings|revenue|profit) (beat|miss|exceed|fall short)",
                "sentiment": "contextual",
                "weight": 0.9
            },
            {
                "pattern": r"(buy|sell|hold) (recommendation|rating|signal)",
                "sentiment": "contextual",
                "weight": 0.8
            }
        ]
    
    async def analyze_sentiment(self, text: str, symbol: str = "UNKNOWN") -> SentimentResult:
        """
        Perform comprehensive sentiment analysis
        
        Args:
            text: Text to analyze
            symbol: Financial symbol for context
            
        Returns:
            SentimentResult with detailed analysis
        """
        try:
            self.logger.debug(f"Analyzing sentiment for {symbol}")
            
            # Multiple analysis approaches
            textblob_result = await self._analyze_with_textblob(text)
            keyword_result = await self._analyze_with_keywords(text)
            pattern_result = await self._analyze_with_patterns(text)
            financial_result = await self._analyze_financial_sentiment(text, symbol)
            
            # Combine results with weighted averaging
            combined_result = await self._combine_sentiment_results(
                textblob_result, keyword_result, pattern_result, financial_result
            )
            
            # Calculate confidence score
            confidence = await self._calculate_confidence(
                text, combined_result, [textblob_result, keyword_result, pattern_result, financial_result]
            )
            
            result = SentimentResult(
                polarity=combined_result["polarity"],
                label=combined_result["label"],
                confidence=confidence
            )
            
            self.logger.debug(f"Sentiment analysis completed: {result.label} ({result.polarity:.2f})")
            return result
            
        except Exception as e:
            self.logger.error(f"Sentiment analysis failed: {e}")
            return SentimentResult(
                polarity=0.0,
                label="neutral",
                confidence=0.0
            )
    
    async def _analyze_with_textblob(self, text: str) -> Dict[str, Any]:
        """Analyze sentiment using TextBlob"""
        try:
            from textblob import TextBlob
            
            blob = TextBlob(text)
            polarity = blob.sentiment.polarity
            
            # Convert polarity to label
            if polarity > 0.1:
                label = "positive"
            elif polarity < -0.1:
                label = "negative"
            else:
                label = "neutral"
            
            return {
                "polarity": polarity,
                "label": label,
                "method": "textblob",
                "confidence": abs(polarity)
            }
            
        except ImportError:
            self.logger.warning("TextBlob not available, using fallback")
            return await self._analyze_with_keywords(text)
        except Exception as e:
            self.logger.error(f"TextBlob analysis failed: {e}")
            return {"polarity": 0.0, "label": "neutral", "method": "textblob", "confidence": 0.0}
    
    async def _analyze_with_keywords(self, text: str) -> Dict[str, Any]:
        """Analyze sentiment using keyword matching"""
        text_lower = text.lower()
        words = re.findall(r'\b\w+\b', text_lower)
        
        positive_count = sum(1 for word in words if word in self._positive_keywords)
        negative_count = sum(1 for word in words if word in self._negative_keywords)
        
        total_sentiment_words = positive_count + negative_count
        
        if total_sentiment_words == 0:
            polarity = 0.0
            label = "neutral"
            confidence = 0.0
        else:
            polarity = (positive_count - negative_count) / total_sentiment_words
            if polarity > 0.2:
                label = "positive"
            elif polarity < -0.2:
                label = "negative"
            else:
                label = "neutral"
            
            confidence = min(total_sentiment_words / 10, 1.0)  # More words = higher confidence
        
        return {
            "polarity": polarity,
            "label": label,
            "method": "keywords",
            "confidence": confidence,
            "positive_words": positive_count,
            "negative_words": negative_count,
            "total_sentiment_words": total_sentiment_words
        }
    
    async def _analyze_with_patterns(self, text: str) -> Dict[str, Any]:
        """Analyze sentiment using financial patterns"""
        text_lower = text.lower()
        pattern_matches = []
        
        for pattern_info in self._financial_patterns:
            pattern = pattern_info["pattern"]
            matches = re.findall(pattern, text_lower)
            
            if matches:
                pattern_matches.append({
                    "pattern": pattern,
                    "matches": matches,
                    "weight": pattern_info["weight"]
                })
        
        if not pattern_matches:
            return {"polarity": 0.0, "label": "neutral", "method": "patterns", "confidence": 0.0}
        
        # Calculate weighted sentiment from patterns
        total_weight = 0
        weighted_polarity = 0
        
        for match in pattern_matches:
            weight = match["weight"]
            match_text = " ".join(match["matches"][0] if match["matches"] else [])
            
            # Determine sentiment direction from match context
            match_polarity = self._determine_pattern_sentiment(match_text)
            
            weighted_polarity += match_polarity * weight
            total_weight += weight
        
        if total_weight > 0:
            final_polarity = weighted_polarity / total_weight
            label = "positive" if final_polarity > 0 else "negative" if final_polarity < 0 else "neutral"
            confidence = min(total_weight / 2, 1.0)  # More patterns = higher confidence
        else:
            final_polarity = 0.0
            label = "neutral"
            confidence = 0.0
        
        return {
            "polarity": final_polarity,
            "label": label,
            "method": "patterns",
            "confidence": confidence,
            "pattern_matches": len(pattern_matches)
        }
    
    def _determine_pattern_sentiment(self, match_text: str) -> float:
        """Determine sentiment from pattern match text"""
        positive_indicators = ["rising", "gaining", "up", "higher", "beat", "exceeds", "buy"]
        negative_indicators = ["falling", "dropping", "losing", "down", "lower", "miss", "sell"]
        
        text_lower = match_text.lower()
        
        positive_score = sum(1 for indicator in positive_indicators if indicator in text_lower)
        negative_score = sum(1 for indicator in negative_indicators if indicator in text_lower)
        
        if positive_score > negative_score:
            return 0.8
        elif negative_score > positive_score:
            return -0.8
        else:
            return 0.0
    
    async def _analyze_financial_sentiment(self, text: str, symbol: str) -> Dict[str, Any]:
        """Analyze financial-specific sentiment"""
        text_lower = text.lower()
        
        # Financial sentiment indicators
        bullish_indicators = [
            "bull market", "bullish", "rally", "surge", "breakout", "momentum",
            "uptrend", "higher highs", "support level", "resistance breakout"
        ]
        
        bearish_indicators = [
            "bear market", "bearish", "crash", "collapse", "breakdown", "downtrend",
            "lower lows", "resistance level", "support breakdown"
        ]
        
        bullish_count = sum(1 for indicator in bullish_indicators if indicator in text_lower)
        bearish_count = sum(1 for indicator in bearish_indicators if indicator in text_lower)
        
        # Check for symbol-specific sentiment
        symbol_mentioned = symbol.lower() in text_lower
        symbol_weight = 1.5 if symbol_mentioned else 1.0
        
        total_indicators = bullish_count + bearish_count
        
        if total_indicators == 0:
            polarity = 0.0
            label = "neutral"
            confidence = 0.0
        else:
            polarity = ((bullish_count - bearish_count) / total_indicators) * symbol_weight
            polarity = max(-1.0, min(1.0, polarity))  # Clamp to [-1, 1]
            
            if polarity > 0.3:
                label = "positive"
            elif polarity < -0.3:
                label = "negative"
            else:
                label = "neutral"
            
            confidence = min(total_indicators / 5, 1.0) * symbol_weight
        
        return {
            "polarity": polarity,
            "label": label,
            "method": "financial",
            "confidence": confidence,
            "bullish_indicators": bullish_count,
            "bearish_indicators": bearish_count,
            "symbol_mentioned": symbol_mentioned
        }
    
    async def _combine_sentiment_results(self, *results) -> Dict[str, Any]:
        """Combine multiple sentiment analysis results"""
        valid_results = [r for r in results if r.get("confidence", 0) > 0]
        
        if not valid_results:
            return {"polarity": 0.0, "label": "neutral", "confidence": 0.0}
        
        # Weighted average based on confidence
        total_weight = sum(r["confidence"] for r in valid_results)
        
        if total_weight == 0:
            return {"polarity": 0.0, "label": "neutral", "confidence": 0.0}
        
        weighted_polarity = sum(
            r["polarity"] * r["confidence"] for r in valid_results
        ) / total_weight
        
        # Determine final label
        if weighted_polarity > 0.15:
            label = "positive"
        elif weighted_polarity < -0.15:
            label = "negative"
        else:
            label = "neutral"
        
        return {
            "polarity": weighted_polarity,
            "label": label,
            "confidence": min(total_weight / len(valid_results), 1.0),
            "methods_used": [r["method"] for r in valid_results]
        }
    
    async def _calculate_confidence(self, 
                                  text: str, 
                                  combined_result: Dict[str, Any], 
                                  individual_results: List[Dict[str, Any]]) -> float:
        """Calculate overall confidence score"""
        # Base confidence from combined result
        base_confidence = combined_result.get("confidence", 0.0)
        
        # Text length factor (longer texts generally have more reliable sentiment)
        text_length_factor = min(len(text.split()) / 20, 1.0)
        
        # Method agreement factor (higher when different methods agree)
        labels = [r["label"] for r in individual_results if r.get("confidence", 0) > 0]
        if len(set(labels)) == 1 and len(labels) > 1:  # All methods agree
            agreement_factor = 1.2
        elif len(set(labels)) <= 2:  # Most methods agree
            agreement_factor = 1.0
        else:  # Methods disagree
            agreement_factor = 0.8
        
        # Financial context factor
        financial_keywords = ["stock", "market", "price", "trade", "invest"]
        financial_context = any(keyword in text.lower() for keyword in financial_keywords)
        context_factor = 1.1 if financial_context else 1.0
        
        # Calculate final confidence
        final_confidence = base_confidence * text_length_factor * agreement_factor * context_factor
        return min(max(final_confidence, 0.0), 1.0)  # Clamp to [0, 1]
    
    async def batch_analyze(self, texts: List[str], symbols: List[str] = None) -> List[SentimentResult]:
        """Analyze sentiment for multiple texts in parallel"""
        if symbols is None:
            symbols = ["UNKNOWN"] * len(texts)
        elif len(symbols) != len(texts):
            symbols = ["UNKNOWN"] * len(texts)
        
        tasks = [
            self.analyze_sentiment(text, symbol)
            for text, symbol in zip(texts, symbols)
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Filter out exceptions and return valid results
        valid_results = []
        for result in results:
            if isinstance(result, Exception):
                self.logger.error(f"Batch sentiment analysis error: {result}")
                valid_results.append(SentimentResult(polarity=0.0, label="neutral", confidence=0.0))
            else:
                valid_results.append(result)
        
        return valid_results
    
    async def get_sentiment_stats(self) -> Dict[str, Any]:
        """Get sentiment engine statistics"""
        return {
            "positive_keywords_count": len(self._positive_keywords),
            "negative_keywords_count": len(self._negative_keywords),
            "financial_patterns_count": len(self._financial_patterns),
            "cache_size": len(self._sentiment_cache),
            "available_methods": ["textblob", "keywords", "patterns", "financial"]
        }


# Global sentiment engine instance
sentiment_engine = SentimentEngine()
