name: Enterprise CI/CD Pipeline

on:
  push:
    branches: [ main, develop, 'feature/*', 'hotfix/*' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

# Concurrency control to cancel redundant runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.21'
  RUST_VERSION: '1.75'
  BUF_VERSION: '1.28.1'
  NODE_VERSION: '20'

jobs:
  # ===== LINTING & QUALITY =====
  lint-quality:
    name: ðŸ” Linting & Quality
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        service: [go-api-gateway, rust-core-engine]
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ¹ Setup Go (for Go service)
        if: matrix.service == 'go-api-gateway'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: ./microservices/go-services/api-gateway/go.mod

      - name: ðŸ¦€ Setup Rust (for Rust service)
        if: matrix.service == 'rust-core-engine'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          components: rustfmt, clippy
          override: true

      - name: ðŸ”§ Go Linting & Formatting
        if: matrix.service == 'go-api-gateway'
        working-directory: ./microservices/go-services/api-gateway
        run: |
          echo "ðŸ” Running Go quality checks..."
          
          # Check formatting
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "âŒ Go files are not formatted:"
            gofmt -s -l .
            exit 1
          fi
          echo "âœ… Go formatting check passed"
          
          # Run golangci-lint
          golangci-lint run --timeout=10m --verbose
          echo "âœ… Go linting completed"

      - name: ðŸ¦€ Rust Linting & Formatting
        if: matrix.service == 'rust-core-engine'
        working-directory: ./microservices/rust-services/core-engine
        run: |
          echo "ðŸ” Running Rust quality checks..."
          
          # Check formatting
          cargo fmt --all -- --check
          echo "âœ… Rust formatting check passed"
          
          # Run clippy
          cargo clippy --all-targets --all-features -- -D warnings
          echo "âœ… Rust clippy completed"

  # ===== SECURITY (SAST) =====
  security-scan:
    name: ðŸ”’ Security Scan (SAST)
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        service: [go-api-gateway, rust-core-engine]
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ¹ Setup Go (for Go service)
        if: matrix.service == 'go-api-gateway'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: ðŸ¦€ Setup Rust (for Rust service)
        if: matrix.service == 'rust-core-engine'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: ðŸ” Go Security Scan
        if: matrix.service == 'go-api-gateway'
        working-directory: ./microservices/go-services/api-gateway
        run: |
          echo "ðŸ” Running Go security scan..."
          
          # Install security tools
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          
          # Run security scan
          gosec -fmt sarif -out gosec-report.sarif ./...
          echo "âœ… Go security scan completed"

      - name: ðŸ” Rust Security Scan
        if: matrix.service == 'rust-core-engine'
        working-directory: ./microservices/rust-services/core-engine
        run: |
          echo "ðŸ” Running Rust security scan..."
          
          # Install security tools
          cargo install cargo-audit cargo-deny
          
          # Run security audit
          cargo audit --json > cargo-audit.json || true
          cargo deny check --output-format json > cargo-deny.json || true
          echo "âœ… Rust security scan completed"

      - name: ðŸ” Trivy Vulnerability Scan
        if: matrix.service == 'rust-core-engine'
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './microservices/rust-services/core-engine'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: ðŸ“¤ Upload Security Reports
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: |
            ${{ matrix.service == 'go-api-gateway' && 'microservices/go-services/api-gateway/gosec-report.sarif' || '' }}
            ${{ matrix.service == 'rust-core-engine' && 'microservices/rust-services/core-engine/trivy-results.sarif' || '' }}

  # ===== BUILD & TEST =====
  build-test:
    name: ðŸ—ï¸ Build & Test
    runs-on: ubuntu-latest
    needs: [lint-quality, security-scan]
    
    strategy:
      matrix:
        service: [go-api-gateway, rust-core-engine]
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ¹ Setup Go (for Go service)
        if: matrix.service == 'go-api-gateway'
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: ./microservices/go-services/api-gateway/go.mod

      - name: ðŸ¦€ Setup Rust (for Rust service)
        if: matrix.service == 'rust-core-engine'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          components: rustfmt, clippy

      - name: ðŸ“¦ Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ${{ matrix.service == 'go-api-gateway' && '~/.cache/go-build' || '' }}
            ${{ matrix.service == 'go-api-gateway' && '~/go/pkg/mod' || '' }}
            ${{ matrix.service == 'rust-core-engine' && '~/.cargo/registry/index' || '' }}
            ${{ matrix.service == 'rust-core-engine' && '~/.cargo/registry/cache' || '' }}
            ${{ matrix.service == 'rust-core-engine' && '~/.cargo/git/db' || '' }}
            ${{ matrix.service == 'rust-core-engine' && 'target' || '' }}
          key: ${{ runner.os }}-${{ matrix.service }}-${{ hashFiles(matrix.service == 'go-api-gateway' && '**/go.sum' || '**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.service }}-

      - name: ðŸ¹ Go Build & Test
        if: matrix.service == 'go-api-gateway'
        working-directory: ./microservices/go-services/api-gateway
        run: |
          echo "ðŸ—ï¸ Building and testing Go service..."
          
          # Download dependencies
          go mod download
          go mod verify
          
          # Run tests with coverage
          go test -v -race -coverprofile=coverage.out ./...
          
          # Build binary
          go build -v -o api-gateway ./cmd/api-gateway
          
          echo "âœ… Go build and test completed"

      - name: ðŸ¦€ Rust Build & Test
        if: matrix.service == 'rust-core-engine'
        working-directory: ./microservices/rust-services/core-engine
        run: |
          echo "ðŸ—ï¸ Building and testing Rust service..."
          
          # Install coverage tool
          cargo install cargo-tarpaulin
          
          # Run tests with coverage
          cargo test --all-features --verbose
          cargo tarpaulin --out Xml --output-dir ./coverage
          
          # Build release
          cargo build --release --verbose
          
          echo "âœ… Rust build and test completed"

      - name: ðŸ“¤ Upload Coverage Reports
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: |
            ${{ matrix.service == 'go-api-gateway' && 'microservices/go-services/api-gateway/coverage.out' || '' }}
            ${{ matrix.service == 'rust-core-engine' && 'microservices/rust-services/core-engine/coverage/cobertura.xml' || '' }}
          flags: ${{ matrix.service }}
          name: ${{ matrix.service }}-coverage

  # ===== PROTOBUF VALIDATION =====
  protobuf-validation:
    name: ðŸ“‹ Protobuf Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Install Buf
        run: |
          curl -sSL "https://github.com/bufbuild/buf/releases/download/v${{ env.BUF_VERSION }}/buf-$(uname -s)-$(uname -m)" -o "/tmp/buf"
          chmod +x "/tmp/buf"
          sudo mv "/tmp/buf" /usr/local/bin/buf

      - name: ðŸ” Validate Protobuf
        working-directory: ./microservices/proto
        run: |
          echo "ðŸ“‹ Validating protobuf files..."
          
          # Validate configuration
          buf config validate
          
          # Lint protobuf files
          buf lint
          
          # Check for breaking changes
          buf breaking --against 'https://github.com/${{ github.repository }}.git#branch=main'
          
          echo "âœ… Protobuf validation completed"

  # ===== INTEGRATION TESTS =====
  integration-tests:
    name: ðŸ”— Integration Tests
    runs-on: ubuntu-latest
    needs: [build-test, protobuf-validation]
    if: github.event_name != 'pull_request'
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ³ Setup Docker
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose

      - name: ðŸš€ Start Services
        working-directory: ./microservices
        run: |
          echo "ðŸš€ Starting services for integration tests..."
          
          # Start observability stack
          docker-compose -f docker-compose-observability.yml up -d
          
          # Wait for observability services
          timeout 300 bash -c 'until docker-compose -f docker-compose-observability.yml ps | grep -q "healthy"; do sleep 5; done'
          
          # Build and start application services
          docker-compose -f docker-compose.yml up -d --build
          
          # Wait for application services
          timeout 300 bash -c 'until curl -f http://localhost:8080/api/v1/health; do sleep 5; done'
          timeout 300 bash -c 'until curl -f http://localhost:50052; do sleep 5; done'
          
          echo "âœ… Services started successfully"

      - name: ðŸ”— Run Integration Tests
        working-directory: ./microservices
        run: |
          echo "ðŸ”— Running integration tests..."
          
          # Run service tests
          docker-compose -f docker-compose.yml exec api-gateway go test -v ./...
          docker-compose -f docker-compose.yml exec core-engine cargo test
          
          # Run E2E validation
          chmod +x scripts/e2e-validation.sh
          ./scripts/e2e-validation.sh
          
          echo "âœ… Integration tests completed"

      - name: ðŸ“Š Collect Logs
        if: failure()
        working-directory: ./microservices
        run: |
          echo "ðŸ“Š Collecting failure logs..."
          
          docker-compose -f docker-compose.yml logs --no-color > integration-test-logs.txt
          docker-compose -f docker-compose-observability.yml logs --no-color > observability-logs.txt

      - name: ðŸ“¤ Upload Test Logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-logs
          path: |
            ./microservices/integration-test-logs.txt
            ./microservices/observability-logs.txt
          retention-days: 7

  # ===== DEPLOYMENT =====
  deploy:
    name: ðŸš€ Deploy
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸš€ Deploy to Production
        run: |
          echo "ðŸš€ Deploying to production environment..."
          echo "ðŸ“Š Deployment metrics:"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Actor: ${{ github.actor }}"
          
          # Add your deployment commands here
          # Example: kubectl apply -f k8s/production/
          # Example: docker-compose -f docker-compose.prod.yml up -d
          
          echo "âœ… Deployment completed"

      - name: ðŸ§ª Run Smoke Tests
        run: |
          echo "ðŸ§ª Running production smoke tests..."
          
          # Add smoke test commands here
          # Example: curl -f http://production-url/api/v1/health
          
          echo "âœ… Smoke tests completed"

  # ===== NOTIFICATION =====
  notify:
    name: ðŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
      - name: ðŸ“¢ Send Notification
        run: |
          echo "ðŸ“¢ Pipeline completed!"
          echo "ðŸ“Š Results:"
          echo "  - Status: ${{ job.status }}"
          echo "  - Commit: ${{ github.sha }}"
          echo "  - Branch: ${{ github.ref_name }}"
          echo "  - Actor: ${{ github.actor }}"
          
          # Add notification logic here
          # Example: Slack webhook, email, Teams notification
